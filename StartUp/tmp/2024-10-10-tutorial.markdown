---
layout: default
title: "Your Post Title"
---

# BadgerRL Ubuntu Server

There are currently two machines, badgerrl and badgerrl2, the collowing commands connect to badgerrl

Your badgerrl account:

`<your_first_name(all lower case)>2024@128.105.102.51`

Your badgerrl2 account

`<your_first_name(all lower case)>2024@128.105.102.54`

Default password:

badgerrl

**PS**: All passwords are default to **badgerrl**, including vnc password, net shared folder password, etc ‚Ä¶

### SSH Command

- ~~Deprecated~~
    
    ```jsx
    ssh <your_first_time(all lower case)>2024@us.openport.io -p 20084
    ```
    
    For example, My name is ABC DEF, then 
    
    ```jsx
    ssh abc2024@us.openport.io -p 20084
    ```
    
    Initial password is **badgerrl**
    
    
    ‚ö†Ô∏è To pass the firewall, reverse ssh and websocks is used
    
    GUI: `-X` option is not aviable 
    
    Connection is not guarenteed to be stable
    
    
    

First, connect to WISC VPN

[WiscVPN - How to Install, Connect, Uninstall, and Disconnect WiscVPN Palo Alto GlobalProtect](https://kb.wisc.edu/page.php?id=90370)

Then connect with

```bash
ssh -J <Your_CS_Username>@best-linux.cs.wisc.edu <your_first_name(all lower case)>2024@128.105.102.51
```

The first password is your [cs department account password](https://apps.cs.wisc.edu/accountapp/)

The second password is the your badgerrl account password, initialized to **badgerrl** 


üîë X11 GUI forwarding is supported, you can add -X to your ssh command and try

1. xeyes
2. ~/Shared/BadgerRLSystem/Build/Linux/SimRobot/Develop/SimRobot


## First Login

### Copy your public key


üîë You need to have an ssh public key, if not, generate by (on your own machine)

`ssh-keygen -t rsa -b 4096 -C "your_email@example.com"`



Linux\OSX

On your own machine: `ssh-copy-id -o 'ProxyJump=<Your NetID>@best-linux.cs.wisc.edu‚Äô' yuhao2024@128.105.102.51`

```jsx
ssh-copy-id -o <Your NetID>@best-linux.cs.wisc.edu <your_first_time(all lower case)>2024@128.105.102.51
```


‚ö†Ô∏è One strange thing is that it might ask for multiple NetID authentification (3-4 times).



Windows

```bash
#On local machine, copy a public key
cat ~/.ssh/id_rsa.pub #Or you can use other public keys end with .pub
#On badgerrl
mkdir -p ~/.ssh && echo "paste_your_public_key_here" >> ~/.ssh/authorized_keys
```

Replace `"paste_your_public_key_here"` with the contents of your `$HOME/.ssh/id_rsa.pub` file that you copied earlier.

### Change password

```jsx
passwd
```

Add the ssh config to you local machine ([**Highly recommended, see optional**](BadgerRL%20Ubuntu%20Server%2071a0150f70404327a35d0f599c22e21d.md))

## Optional

1. **Highly recommended**: Add badgerrl computer in ***~/.ssh/config*** on your local computer
    
    ```bash
    Host badgerrl
        HostName 128.105.102.51
        User <your_first_name(all lower case)>2024
        ProxyJump <Your_CS_Username>@best-linux.cs.wisc.edu
        ForwardX11 yes
    
    Host badgerrl2
        HostName 128.105.102.54
        User <your_first_name(all lower case)>2024
        ProxyJump <Your_CS_Username>@best-linux.cs.wisc.edu
        ForwardX11 yes
    ```
    
    Next time you only need to run
    
    ```bash
    ssh badgerrl
    ssh badgerrl2
    ```
    

1. Generate ssh key on the badgerrl server and add it to github ssh keys
    
    ```bash
    ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
    cat ~/.ssh/id_rsa.pub
    ```
    
2. Init conda - run `conda init` (This doesn‚Äôt really matter, it just make your terminal show the current environment)
3. Go through the Share folder under your home directory (Probably it contains the repo you need, copy and use it)

### Connect Scripts (Save Time, moderately recommended)

1. Prerequisite
    1. [Configure ssh](BadgerRL%20Ubuntu%20Server%2071a0150f70404327a35d0f599c22e21d.md)
    2. Dependency
        1. ssh
        2. expect
        3. tmux (for independent ssh terminal)
        4. brew (MacOS only)
            
            https://brew.sh/
            
            ```bash
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            ```
            
        5. sshfs (MacOS only)
            
            ```bash
            brew install --cask macfuse
            brew install gromgit/fuse/sshfs
            ```
            

### `ssh` connect terminal

```bash
#!/usr/bin/env sh

# The bash/zsh script to create a SSH tunnel to rllab computer
# Automatic cs login, but still need Duo authentication, you can specify the device number
# Before using this script, make sure you have configure badgerrl and badgerrl2 connection in ~/.ssh/config
# and have already copy you ssh key to badgerrl and badgerrl2
# OS: Ubuntu 22.04 LTS
# Last update: 2024-07-23 By Yuhao Li (yli2565@wisc.edu)

cs_password="<Your CS department password>"
default_duo_device="<The number of duo device, usually 1>"
default_remote_username="<Your lab machine account>" # e.g. yuhao2024
default_remote_server_name="<badgerrl/badgerrl2>"    # should be presented in ~/.ssh/config
default_key_password="<Default key password>"
default_timeout=10 # in s

verbose="0"

ssh_key="~/.ssh/id_rsa"
ssh_key=$(eval echo $ssh_key)
# Determine the shellcase "$SHELL" in
case "$SHELL" in
    */bash)
        shell="bash"
        ;;
    */zsh)
        shell="zsh"
        ;;
    *)
        echo "Unsupported shell. Please use bash or zsh."
        exit 1
        ;;
esac

script_name=$(basename "$0")
script_base_name="${script_name%.*}"

# Function to display usage information
usage() {
    echo "usage: $script_base_name [-d device] [-u username] [-s server] [-p password] [-k key-password] [-t timeout] [-h] [param1 [param2 [param3]]]"
    exit 1
}
verbose1() {
    if  [ "$verbose" -gt 0 ]; then
        echo "$@"
    fi
}
check_required_arguments() {
    value="$1"
    variable_name="$2"
    if [ "${value#<}" != "$value" ] && [ "${value%>}" != "$value" ]; then
        echo "${variable_name} not set properly"
        exit 1
    fi
}
parse_args() {
    if [ "$shell" = "zsh" ]; then
        while getopts "d:u:s:p:k:t:h-:" opt; do
            case "$opt" in
            -)
                case "${OPTARG}" in
                device)
                    device="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                username)
                    username="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                server)
                    server="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                password)
                    password="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                key-password)
                    key_password="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                timeout)
                    timeout="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                help)
                    usage
                    ;;
                *)
                    echo "Unknown option --${OPTARG}" >&2
                    usage
                    ;;
                esac
                ;;
            d)
                device="$OPTARG"
                ;;
            u)
                username="$OPTARG"
                ;;
            s)
                server="$OPTARG"
                ;;
            p)
                password="$OPTARG"
                ;;
            t)
                timeout="$OPTARG"
                ;;
            k)
                key_password="$OPTARG"
                ;;
            h)
                usage
                ;;
            *)
                echo "Unknown option -${opt}" >&2
                usage
                ;;
            esac
        done

        shift $((OPTIND - 1))
    elif [ "$shell" = "bash" ]; then
        # Parse options with getopts
        OPTIONS=d:u:s:p:k:t:h
        LONGOPTIONS=device:,username:,server:,password:,key-password:,timeout:,help

        # -temporarily store output to be able to check for errors
        PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTIONS --name "$0" -- "$@")
        if [ $? -ne 0 ]; then
            usage
        fi

        # read getopt‚Äôs output this way to handle the quoting right:
        eval set -- "$PARSED"

        # Process each option
        while true; do
            case "$1" in
            -d | --device)
                device="$2"
                shift 2
                ;;
            -u | --username)
                username="$2"
                shift 2
                ;;
            -s | --server)
                server="$2"
                shift 2
                ;;
            -p | --password)
                password="$2"
                shift 2
                ;;
            -t | --timeout)
                timeout="$2"
                shift 2
                ;;
            -k | --key-password)
                key_password="$2"
                shift 2
                ;;
            -h | --help)
                usage
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
            esac
        done
    else
        echo "Unsupported shell. Please use bash or zsh."
        return 1
    fi

    # Handle positional parameters
    if [ $# -gt 3 ]; then
        echo "Error: Too many positional parameters" 1>&2
        usage
    fi

    # Assign positional parameters if provided
    if [ $# -ge 1 ]; then
        device=$1
    fi

    if [ $# -ge 2 ]; then
        username=$2
    fi

    if [ $# -ge 3 ]; then
        server=$3
    fi
}
# Initialize variables with default values
device="$default_duo_device"
username="$default_remote_username"
server="$default_remote_server_name"
password="$cs_password"
key_password="$default_key_password"
timeout="$default_timeout"

parse_args "$@"

check_required_arguments "$device" "device"
check_required_arguments "$username" "username"
check_required_arguments "$server" "server"
check_required_arguments "$password" "password"
# Key password is optional

# Debug output
verbose1 "Duo Device: $device"
verbose1 "Username: $username"
verbose1 "Remote Server: $server"
verbose1 "Password: $password"
verbose1 "Key Password: $key_password"
verbose1 "Timeout: $timeout"
verbose1 "Verbose: $verbose"

remote_ip=$(ssh -G "${server}" | grep "^hostname " | awk '{print $2}')
verbose1 "Remote IP: $remote_ip"

# Ensure remote_ip is retrieved correctly
if [ -z "$remote_ip" ]; then
    echo "Failed to get remote IP for host ${server}"
    exit 1
fi

# Add ssh key to ssh agent
eval "$(ssh-agent -s)" 2>&1 > /dev/null
/usr/bin/expect <<EOF 2>&1 > /dev/null
spawn ssh-add ${ssh_key}
expect {
    -re {Enter passphrase for .*:} {send "${key_password}\r"; exp_continue}
    -re {Identity added: .*} {exit 0}
}
EOF

# Kill tmux session with no client (not used)
sessions=$(tmux list-sessions -F '#S' 2>/dev/null)

max_digits=0
for session in $sessions; do
    if echo "$session" | grep -q "^${server}_terminal_[0-9]\+$"; then
        digits=$(echo $session | grep -o '[0-9]\+$')
        clients=$(tmux list-clients -t $session 2>/dev/null)

        if [ -z "$clients" ]; then
            tmux kill-session -t $session
            verbose1 "Killed session: $session"
        else
            if ((digits >max_digits)); then
                max_digits=$digits
            fi
        fi
    fi
done
new_terminal_number=$((max_digits + 1))

expectScript=$(mktemp)
expectScriptLog=$(mktemp)
verbose1 "Script: ${expectScript}"
cat <<EOF >"$expectScript"
set timeout -1
spawn tmux new-session -s ${server}_terminal_${new_terminal_number} sh -c "echo ssh PID: \\\$\\\$; exec ssh ${username}@${server}"
expect {
    -re {\(.*@best-linux\.cs\.wisc\.edu\) Password:} {send "${password}\r"; exp_continue}
    -re {Passcode or option \(1-[1-9][0-9]*\)} {send "${device}\r"; exp_continue}
    -re {Enter passphrase for key .*:} {send "${key_password}\r"; exp_continue}
    -re {${username}@.*:.*\$} {send "clear && source ~/.bashrc\r"}
}
expect eof
EOF
/usr/bin/expect "${expectScript}" 2>&1 >"${expectScriptLog}" &
expect_pid="$!"
disown "$expect_pid"

verbose1 "Disowned PID: "$expect_pid""
time_sleep=0.25 # seconds
max_attempts=$(echo "$timeout / $time_sleep" | bc)

# Loop to check if the tunnel is established
count=0
verbose1 "Log: ${expectScriptLog}"

while ! grep -q "${username}@.*:.*$" "${expectScriptLog}"; do
    ssh_pid=$(grep -o "ssh[[:space:]]PID:[[:space:]][0-9][0-9]*" "${expectScriptLog}" | sed 's/.*PID:[[:space:]]\([0-9]*\)/\1/')
    # echo "SSH PID: $ssh_pid"
    if [ -n "$ssh_pid" ]; then
        tmux_pid=$(expr $(ps -o ppid= -p $ssh_pid) + 0)
    fi

    sleep "$time_sleep"
    ((count++))

    if ((count >= max_attempts)); then
        echo "Failed to establish SSH tunnel after ${timeout} seconds."

        if kill -0 "$expect_pid" 2>/dev/null; then
            kill -9 "$expect_pid"
            echo "Killed SSH tunnel process."
        fi
        tmux kill-session -t "${server}_terminal_${new_terminal_number}"
        exit 1
    fi
done

if grep -q "${username}@.*:.*$" "${expectScriptLog}"; then
    if tmux list-sessions | grep -q "${server}_terminal_${new_terminal_number}"; then
        tmux detach-client -s "${server}_terminal_${new_terminal_number}"
    fi
    tmux attach-session -t "${server}_terminal_${new_terminal_number}"
fi

```

### `sftp` Map the remote folder to local machine

```bash
#!/usr/bin/env sh

# The bash/zsh script to mount rllab computer to your own machine
# Automatic cs login, but still need Duo authentication, you can specify the device number
# Before using this script, make sure you have configure badgerrl and badgerrl2 connection in ~/.ssh/config
# and have already copy you ssh key to badgerrl and badgerrl2
# OS: Ubuntu 22.04 LTS
# Last update: 2024-07-23 By Yuhao Li (yli2565@wisc.edu)

# TODO: make key_password a long option, enable initial connect (Put ssh config into configuration / fingerprint yes/enter password/copy key)
# TODO: make zsh and bash both use get opts

cs_password="<Your CS department password>"
default_duo_device="<The number of duo device, usually 1>"
default_remote_username="<Your lab machine account>" # e.g. yuhao2024
default_remote_server_name="<badgerrl/badgerrl2>"    # should be presented in ~/.ssh/config
default_key_password="<Default key password>"

verbose="0"

ssh_key="~/.ssh/id_rsa"
ssh_key=$(eval echo $ssh_key)

default_timeout=10 # in s
port_range_start=22200
port_range_end=22400

# Determine the shell
case "$SHELL" in
    */bash)
        shell="bash"
        ;;
    */zsh)
        shell="zsh"
        ;;
    *)
        echo "Unsupported shell. Please use bash or zsh."
        exit 1
        ;;
esac

script_name=$(basename "$0")
script_base_name="${script_name%.*}"

# Function to display usage information
usage() {
    echo "usage: $script_base_name [-d device] [-u username] [-s server] [-p password] [-k key-password] [-t timeout] [-v verbose] [-h] [param1 [param2 [param3]]]"
    exit 1
}
verbose1() {
    if  [ "$verbose" -gt 0 ]; then
        echo "$@"
    fi
}
check_required_arguments() {
    value="$1"
    variable_name="$2"
    if [ "${value#<}" != "$value" ] && [ "${value%>}" != "$value" ]; then
        echo "${variable_name} not set properly"
        exit 1
    fi
}
get_md5_hash_truc14() {
    local port=$1
    if [ "$shell" = "zsh" ]; then
        local hash=$(echo -n "$string" | md5)
    elif [ "$shell" = "bash" ]; then
        local hash=$(echo -n "$string" | md5sum | awk '{print $1}')
    else
        echo "Unsupported shell. Please use bash or zsh."
        return 1
    fi
    if [ $? -ne 0 ]; then
        echo "Error: Failed to get MD5 hash." >&2
        return 1
    fi
    local truncated_hash=$(echo "$hash" | cut -c 1-14) # Truncate the hash to 14 characters
    echo "$truncated_hash"
    return 0
}
is_port_in_use() {
    local port=$1
    if [ "$shell" = "zsh" ]; then
        netstat -an | grep LISTEN | grep -q "127.0.0.1.${port} "
    elif [ "$shell" = "bash" ]; then
        netstat -tuln | grep -q "127.0.0.1:${port} "
    else
        echo "Unsupported shell. Please use bash or zsh."
        return 1
    fi
    return $?
}
hash_to_port_range() {
    local string="$1"
    if [ -z "$string" ]; then
        echo "Error: Input string is empty." >&2
        return 1
    fi
    local truncated_hash=$(get_md5_hash_truc14 "$string")
    # echo "Truncated Hash: $truncated_hash"
    if [ $? -ne 0 ]; then
        echo "Error: Failed to convert hash to decimal." >&2
        return 1
    fi
    local decimal=$(printf "%d\n" "0x$truncated_hash")
    # echo "Decimal: $decimal"
    local port_range=$((port_range_end - port_range_start + 1))
    local port=$((decimal % port_range + port_range_start))
    echo "$port"
    return 0
}
parse_args() {
    if [ "$shell" = "zsh" ]; then
        while getopts "d:u:s:p:k:t:h-:" opt; do
            case "$opt" in
            -)
                case "${OPTARG}" in
                device)
                    device="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                username)
                    username="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                server)
                    server="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                password)
                    password="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                key-password)
                    key_password="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                timeout)
                    timeout="${!OPTIND}"
                    OPTIND=$((OPTIND + 1))
                    ;;
                help)
                    usage
                    ;;
                *)
                    echo "Unknown option --${OPTARG}" >&2
                    usage
                    ;;
                esac
                ;;
            d)
                device="$OPTARG"
                ;;
            u)
                username="$OPTARG"
                ;;
            s)
                server="$OPTARG"
                ;;
            p)
                password="$OPTARG"
                ;;
            k)
                key_password="$OPTARG"
                ;;
            t)
                timeout="$OPTARG"
                ;;
            h)
                usage
                ;;
            *)
                echo "Unknown option -${opt}" >&2
                usage
                ;;
            esac
        done

        shift $((OPTIND - 1))
    elif [ "$shell" = "bash" ]; then
        # Parse options with getopts
        OPTIONS=d:u:s:p:k:t:h
        LONGOPTIONS=device:,username:,server:,password:,key-password:,timeout:,help

        # -temporarily store output to be able to check for errors
        PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTIONS --name "$0" -- "$@")
        if [ $? -ne 0 ]; then
            usage
        fi

        # read getopt‚Äôs output this way to handle the quoting right:
        eval set -- "$PARSED"

        # Process each option
        while true; do
            case "$1" in
            -d | --device)
                device="$2"
                shift 2
                ;;
            -u | --username)
                username="$2"
                shift 2
                ;;
            -s | --server)
                server="$2"
                shift 2
                ;;
            -p | --password)
                password="$2"
                shift 2
                ;;
            -k | --key-password)
                key_password="$2"
                shift 2
                ;;
            -t | --timeout)
                timeout="$2"
                shift 2
                ;;
            -h | --help)
                usage
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "Programming error"
                exit 3
                ;;
            esac
        done
    else
        echo "Unsupported shell. Please use bash or zsh."
        return 1
    fi

    # Handle positional parameters
    if [ $# -gt 3 ]; then
        echo "Error: Too many positional parameters" 1>&2
        usage
    fi

    # Assign positional parameters if provided
    if [ $# -ge 1 ]; then
        device=$1
    fi

    if [ $# -ge 2 ]; then
        username=$2
    fi

    if [ $# -ge 3 ]; then
        server=$3
    fi
}
mount_ext4_on_osx() {
    local local_folder="$1"
    local remote_folder="$2"
    local ovolname=$(basename "$local_folder")
    mkdir -p "${local_folder}"
    if mount | grep -q "on ${local_folder} .*macfuse"; then
        verbose1 "Folder ${remote_folder} of ${username} on ${server} already mounted at ${local_folder}"
    else
        sshfs -p "${local_port}" "${username}@localhost:${remote_folder}" "${local_folder}" -ovolname="${ovolname}"
        verbose1 "Folder ${remote_folder} of ${username} on ${server} mounted at ${local_folder}"
    fi
    open "${local_folder}"
}

# Initialize variables with default values
device="$default_duo_device"
username="$default_remote_username"
server="$default_remote_server_name"
password="$cs_password"
key_password="$default_key_password"
timeout="$default_timeout"

parse_args "$@"

check_required_arguments "$device" "device"
check_required_arguments "$username" "username"
check_required_arguments "$server" "server"
check_required_arguments "$password" "password"
# Key password is optional

# Debug output
verbose1 "Duo Device: $device"
verbose1 "Username: $username"
verbose1 "Remote Server: $server"
verbose1 "Password: $password"
verbose1 "Key Password: $key_password"
verbose1 "Timeout: $timeout"
verbose1 "Verbose: $verbose"

remote_ip=$(ssh -G "${server}" | grep "^hostname " | cut -d ' ' -f 2)
verbose1 "Remote IP: $remote_ip"
local_port=$(hash_to_port_range "${remote_ip}") # port range is [22200, 22399]
verbose1 "Local port: $local_port"

# Ensure remote_ip is retrieved correctly
if [ -z "$remote_ip" ]; then
    echo "Failed to get remote IP for host ${server}"
    exit 1
fi

# Add ssh key to ssh agent
eval "$(ssh-agent -s)" 2>&1 > /dev/null
/usr/bin/expect <<EOF 2>&1 > /dev/null
spawn ssh-add ${ssh_key}
expect {
    -re {Enter passphrase for .*:} {send "${key_password}\r"; exp_continue}
    -re {Identity added: .*} {exit 0}
}
EOF

if is_port_in_use "${local_port}"; then
    echo "SSH tunnel already exists on port ${local_port}"
else
    expectScript=$(mktemp)
    cat <<EOF >"$expectScript"
set timeout -1
spawn ssh -N -L ${local_port}:${remote_ip}:22 ${username}@${server}
expect {
    -re {\(.*@best-linux\.cs\.wisc\.edu\) Password:} {send "${password}\r"; exp_continue}
    -re {Passcode or option \(1-[1-9][0-9]*\)} {send "${device}\r"; exp_continue}
    -re {Enter passphrase for key .*:} {send "${key_password}\r"; exp_continue}
    -re {Success\. Logging you in.*} {send "\r"}
}

expect eof
EOF
    /usr/bin/expect "${expectScript}" 2>&1 > /dev/null &

    expect_pid="$!"
    disown "$expect_pid"

    time_sleep=0.25 # seconds
    max_attempts=$(echo "$timeout / $time_sleep" | bc)

    # Loop to check if the tunnel is established
    count=0
    while ! is_port_in_use "${local_port}"; do
        sleep "$time_sleep"
        ((count++))
        if ((count >= max_attempts)); then
            echo "Failed to establish SSH tunnel after ${timeout} seconds."
            if kill -0 "$expect_pid" 2>/dev/null; then
                kill -9 "$expect_pid"
            fi
            exit 1
        fi
    done
fi

if is_port_in_use "${local_port}"; then
    if [ "$shell" = "zsh" ]; then
        mount_ext4_on_osx "${HOME}/${username}HomeOn${server}" "/home/${username}"
        mount_ext4_on_osx "${HOME}/SharedOn${server}" "/home/Shared"
    elif [ "$shell" = "bash" ]; then
        # echo "nautilus \"sftp://${username}@localhost:${local_port}/home/${username}\" --new-window"
        nautilus "sftp://${username}@localhost:${local_port}/home/${username}" --new-window &
    else
        echo "Unsupported shell. Please use bash or zsh."
        return 1
    fi
fi

```

### VNC connection (with GUI) on all MacOS/Linux

```bash
# Login to linux machine (through terminal)

# Run:
bash ~/Shared/start_vnc_server.sh
# The script will printout some instructions, follow them
# Logout of linux machine
```

Running the script above will tell you a `<display number>` and `<portal number>`, where <portal number>=5900+<display number>

### VNC Client

1. Mac:
    
    [TigerVNC-1.12.0.dmg](BadgerRL%20Ubuntu%20Server%2071a0150f70404327a35d0f599c22e21d/TigerVNC-1.12.0.dmg)
    
2. Windows:
    
    [TigerVNC -  Browse /beta/1.14beta at SourceForge.net](https://sourceforge.net/projects/tigervnc/files/beta/1.14beta/)
    
3. Linux:
    
    Remmina
    
    [How to install Remmina](https://remmina.org/how-to-install-remmina/)
    

You can double check the server is running with `ss -tulnp` in remote terminal

To shutdown the server, please use `vncserver -kill :<display number>`

### RDP connection (with GUI) on MacOS/Windows

```bash
# Login to linux machine (through terminal)

# Run:
sudo apt update
sudo apt install xrdp -y
sudo systemctl restart xrdp

# Logout of linux machine

# Now we do the weird stuff. Every time you want to connect you need to run this command in the terminal while you are on the GUI (just leave it open in the background)
# On local machine run (replaced with your stuff):
ssh -J <Your_CS_Username>@best-linux.cs.wisc.edu <your_first_name(all lower case)>2024@128.105.102.51 -L 5555:localhost:3389

In microsoft remote desktop:
Add new PC
Address: localhost:5555

That is all you need there

Double click the new pc to connect

Should pop up with a gui, enter badger rl username and password there (adam2024 and badgerrl for me)
```

### VScode connection


‚ö†Ô∏è VScode is nice, but we met many problems when trying to connect to lab server though vscode

Updated: July 6 2024



1. **Windows:** 
    
    **SSH connection doesn‚Äôt work**
    
    Problem: Cannot install vscode-server extension
    
    - Use Tunneling:
        
        [Kazam_screencast_00036.mp4](BadgerRL%20Ubuntu%20Server%2071a0150f70404327a35d0f599c22e21d/Kazam_screencast_00036.mp4)
        
2. MacOS (OSX): 
    1. **Current version of vscode**
        
        SSH/Tunneling both works fine
        
        SSH: **BE AS FAST AS POSSIBLE WHEN LOGINING IN** (Password + Duo)
        
    2. **Old version of VScode** (indicated by No Tunneling functionality / Only have SSH option)
        
        Currently there‚Äôs **no way to connect to the lab server**
        
        Problems:
        
        1. Infinite login prompt
        2. Cannot install extension
3. **Linux (Ubuntu)**
    
    SSH/Tunneling both works fine
    
    SSH: **BE AS FAST AS POSSIBLE WHEN LOGINING IN** (Password + Duo)
    

## Server Info

- Groups
    
    rllab: Access to the /home/Shared folder
    
- Proxy Setting
    1. For login shells, create ***proxy.sh*** in ***/etc/profile.d/***
        
        ```bash
        export http_proxy="http://squid.cs.wisc.edu:3128/"
        export https_proxy="http://squid.cs.wisc.edu:3128/"
        export ftp_proxy="ftp://squid.cs.wisc.edu:3128/"
        export no_proxy="localhost.127.0.0.1,::1"
        
        #For curl
        export HTTP_PROXY="http://squid.cs.wisc.edu:3128/"
        export HTTPS_PROXY="http://squid.cs.wisc.edu:3128/"
        export FTP_PROXY="ftp://squid.cs.wisc.edu:3128/"
        export NO_PROXY="localhost.127.0.0.1,::1"
        ```
        
    2. For non-ogin shells, add this line in ***/etc/bash.bashrc***: 
        
        ```bash
        source /etc/profile.d/proxy.sh
        ```
        
- Conda Initialization
    1. Use conda initilization script in login shells ***/etc/profile.d/***
        
        ```bash
        ln -s /usr/local/miniconda3/etc/profile.d/conda.sh /etc/profile.d
        ```
        
    2. Init Conda in non-login shells, add following lines in ***/etc/bash.bashrc***: 
        
        ```bash
        # >>> conda initialize >>>
        # !! Contents within this block are managed by 'conda init' !!
        __conda_setup="$('/usr/local/miniconda3/bin/conda' 'shell.bash' 'hook' 2> /dev/null)"
        if [ $? -eq 0 ]; then
            eval "$__conda_setup"
        else
            if [ -f "/usr/local/miniconda3/etc/profile.d/conda.sh" ]; then
                . "/usr/local/miniconda3/etc/profile.d/conda.sh"
            else
                export PATH="/usr/local/miniconda3/bin:$PATH"
            fi
        fi
        unset __conda_setup
        # <<< conda initialize <<<
        ```
        
    3. Global Conda config in ***/etc/conda/.condarc*** 
        
        ```yaml
        envs_dirs:
          - /home/Shared/conda_envs
        ```
        
- Installed Packages
    - Miniconda
        
        AbstractSim_torchcpu - The default conda environment for all users to run AbstractSim.
        
    - All package requried by BadgerRL: ccache clang cmake git graphviz libasound2-dev libbox2d-dev libgl-dev libqt6opengl6-dev libqt6svg6-dev libstdc++-12-dev llvm mold net-tools ninja-build pigz qt6-base-dev rsync xxd
    - xdrp (RDP remote desktop)
    - tigervnc (VNC remote desktop)
    - gnome-tweaks (configure gnome)
    - bashtop (system monitor)
- Passing Firewall
    
    Github can be accessed by 
    
    Configure git to use proxy
    
    ```bash
    git config --global https.proxy [http://squid.cs.wisc.edu:3128](http://squid.cs.wisc.edu:3128/)
    git config --global http.proxy [http://squid.cs.wisc.edu:3128](http://squid.cs.wisc.edu:3128/)
    ```
    
    adding this to ***/etc/ssh/ssh_config***: 
    
    ```jsx
    ProxyCommand corkscrew squid.cs.wisc.edu 3128 %h %p
    
    Host github.com
        User git
        Port 443
        Hostname ssh.github.com
        IdentitiesOnly yes
        TCPKeepAlive yes
        ProxyCommand corkscrew squid.cs.wisc.edu 3128 %h %p
    
    Host ssh.github.com
        User git
        Port 443
        Hostname ssh.github.com
        IdentitiesOnly yes
        TCPKeepAlive yes
        ProxyCommand corkscrew squid.cs.wisc.edu 3128 %h %p
    ```
    
- Conda Env fix
    
    If you see the ERROR related to OpenGL / measa
    
    ```yaml
    cd <conda env directory>/lib
    mkdir backup
    mv libstd* backup
    cp /usr/lib/x86_64-linux-gnu/libstdc++.so.6  ./
    ln -s libstdc++.so.6 libstdc++.so
    ln -s libstdc++.so.6 libstdc++.so.6.0.29
    ```
    

### Installing Commands